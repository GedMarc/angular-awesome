# Angular Awesome Implementation Rules

## Angular 19 Compatibility

This project is built for Angular 19 and must use the latest Angular 19 syntax and features:

1. **Use input() instead of @Input()**: Use the new input() function instead of the @Input() decorator.
   ```typescript
   // Old way
   @Input() value: string = '';

   // New way
   value = input<string>('');
   ```

2. **Use model() for two-way binding**: Use the model() function for two-way bindable properties.
   ```typescript
   // Two-way bindable value
   value = model<string>('');
   ```

3. **Use output() instead of @Output()**: Use the new output() function instead of the @Output() decorator.
   ```typescript
   // Old way
   @Output() valueChange = new EventEmitter<any>();

   // New way
   valueChange = output<any>();
   ```

4. **Use signals for reactive state**: Access input values using function call syntax and subscribe to value changes.
   ```typescript
   // Access input value
   const type = this.type();

   // Subscribe to value changes
   this.value.valueChanged.subscribe((value) => {
     // Handle value change
   });
   ```

5. **Use .apply() for model inputs**: When updating model inputs, use the `.apply()` method instead of `.set()`.
   ```typescript
   // Incorrect
   this.value.set(newValue);

   // Correct
   this.value.apply(newValue);
   ```

6. **Constructor Injection**: Use constructor injection for dependencies and subscribe to value changes.

   For directives with model() values, subscribe to the model value changes in the constructor to ensure ngModel binding works correctly:
   ```typescript
   constructor(private el: ElementRef) {
     this.value.subscribe((value) => {
       this.onModelChange(value);
     });
   }
   ```

   For directives with output() events, subscribe to the output event in the constructor:
   ```typescript
   constructor(private el: ElementRef) {
     this.dateChange.subscribe((value) => {
       this.onModelChange(value);
     });
   }
   ```

   This subscription is essential for ngModel binding to work correctly. It ensures that when the value changes internally (through the model or output), the change is propagated to the Angular form control.

## Data Binding and Angular Integration

The most important rule for this project is to ensure proper data binding between Angular and the web awesome framework. The web awesome framework handles the core functionality, but the Angular wrapper must handle the Angular integration, including two-way data binding and form validation.

### What to Avoid:

1. **No Formatting Logic**: Do not add logic that formats or transforms the displayed values. The web awesome framework handles all display formatting.

2. **No Business Logic**: Do not add business logic or validation rules that should be handled by the web awesome framework.

### What to Do:

1. **Define Inputs and Outputs**: Define inputs and outputs that match the web awesome component's API.

2. **Implement Two-Way Binding**: Ensure all directives support two-way data binding using Angular's model() API.

3. **Support ngModel**: Make directives compatible with ngModel for use in Angular forms by implementing ControlValueAccessor.
   ```typescript
   @Directive({
     selector: 'wa-component',
     standalone: true,
     providers: [
       {
         provide: NG_VALUE_ACCESSOR,
         multi: true,
         useExisting: WaComponentDirective
       }
     ]
   })
   export class WaComponentDirective implements ControlValueAccessor {
     // ControlValueAccessor implementation
     private onModelChange: (value: any) => void = () => {};
     private onTouched: () => void = () => {};

     writeValue(value: any): void {
       if (value !== undefined && value !== null) {
         this.value.apply(value);
       }
     }

     registerOnChange(fn: (value: any) => void): void {
       this.onModelChange = fn;
     }

     registerOnTouched(fn: () => void): void {
       this.onTouched = fn;
     }

     setDisabledState(isDisabled: boolean): void {
       // Implement if needed
     }
   }
   ```

4. **Handle Events**: Add necessary event handlers to ensure data flows correctly between Angular and web awesome components.
   ```typescript
   @HostListener('input', ['$event'])
   onInput(event: any) {
     const value = event.target.value;
     this.value.apply(value);
     this.valueChange.emit(event);
     this.onModelChange(value);
   }
   ```

5. **Support Validation**: Ensure directives properly support Angular form validation by implementing Validator.
   ```typescript
   @Directive({
     selector: 'wa-component',
     standalone: true,
     providers: [
       {
         provide: NG_VALUE_ACCESSOR,
         multi: true,
         useExisting: WaComponentDirective
       },
       {
         provide: NG_VALIDATORS,
         multi: true,
         useExisting: WaComponentDirective
       }
     ]
   })
   export class WaComponentDirective implements ControlValueAccessor, Validator {
     // Validator implementation
     validate(control: AbstractControl): ValidationErrors | null {
       const value = control.value;

       if (value === null || value === undefined || value === '') {
         return null; // Empty values are handled by required validator
       }

       // Add validation logic here

       return null;
     }
   }
   ```

## Handling Standalone Attributes

When implementing directives that need to support standalone attributes (attributes without values), follow these guidelines:

### 1. Use Two or Three Inputs for Each Attribute

For non-hyphenated attributes (e.g., "clearable"):

```typescript
// Regular input for property binding
attributeName = input<boolean>(false);

// Separate input for the standalone attribute
attributeNameAttr = input<string | boolean>('', { alias: 'attributeName' });
```

For hyphenated attributes (e.g., "password-toggle"):

```typescript
// Regular input for property binding
attributeName = input<boolean>(false);

// Separate input for the kebab-case standalone attribute
attributeNameAttr = input<string | boolean>('', { alias: 'attribute-name' });

// Separate input for the camelCase standalone attribute
attributeNameAttrCamel = input<string | boolean>('', { alias: 'attributeName' });
```

### 2. Create a Helper Method

Create a helper method to determine if the attribute is enabled, checking all possible inputs:

For non-hyphenated attributes:

```typescript
isAttributeNameEnabled(): boolean {
  return this.attributeName() ||
         this.attributeNameAttr() === '' ||
         this.attributeNameAttr() === 'true';
}
```

For hyphenated attributes:

```typescript
isAttributeNameEnabled(): boolean {
  return this.attributeName() ||
         this.attributeNameAttr() === '' ||
         this.attributeNameAttr() === 'true' ||
         this.attributeNameAttrCamel() === '' ||
         this.attributeNameAttrCamel() === 'true';
}
```

### 3. Use the Helper Method in Templates and Tests

When checking if the attribute is enabled, use the helper method instead of directly accessing the inputs:

```typescript
// In tests
expect(directive.isAttributeNameEnabled()).toBe(true);

// In templates
<div *ngIf="isAttributeNameEnabled()">...</div>
```

## Examples

### Password Toggle (Hyphenated Attribute)

```typescript
// Regular input for property binding
passwordToggle = input<boolean>(false);

// Separate input for the kebab-case standalone attribute
passwordToggleAttr = input<string | boolean>('', { alias: 'password-toggle' });

// Separate input for the camelCase standalone attribute
passwordToggleAttrCamel = input<string | boolean>('', { alias: 'passwordToggle' });

// Helper method to determine if password toggle is enabled
isPasswordToggleEnabled(): boolean {
  return this.passwordToggle() ||
         this.passwordToggleAttr() === '' ||
         this.passwordToggleAttr() === 'true' ||
         this.passwordToggleAttrCamel() === '' ||
         this.passwordToggleAttrCamel() === 'true';
}
```

### Clearable (Non-Hyphenated Attribute)

```typescript
// Regular input for property binding
clearable = input<boolean>(false);

// Separate input for the standalone attribute
clearableAttr = input<string | boolean>('', { alias: 'clearable' });

// Helper method to determine if clearable is enabled
isClearableEnabled(): boolean {
  return this.clearable() ||
         this.clearableAttr() === '' ||
         this.clearableAttr() === 'true';
}
```

## Use Fixed Values for Input Types

When defining input properties that have a fixed set of possible values, always use a union type instead of a generic string or any type. This ensures type safety and provides better IDE autocompletion.

```typescript
// Bad
type = input<string>('text');

// Good
type = input<'date' | 'datetime-local' | 'email' | 'number' | 'password' | 'search' | 'tel' | 'text' | 'time' | 'url'>('text');
```

This approach should be used for all inputs that have a predefined set of valid values, such as:

1. Input types
2. Display formats
3. Size options
4. Any other property with a fixed set of valid values

### Benefits:

1. **Type Safety**: Prevents assigning invalid values to the property
2. **IDE Support**: Provides autocompletion for valid values
3. **Self-Documentation**: Makes the valid values clear in the code
4. **Error Prevention**: Catches errors at compile time rather than runtime

## Testing

When testing directives with standalone attributes, create tests for all possible syntax variations:

For non-hyphenated attributes:
1. Property binding: `[attribute]="value"`
2. Standalone attribute: `attribute`
3. Attribute with value: `attribute="true"` and `attribute="false"`

For hyphenated attributes:
1. Property binding: `[attribute]="value"`
2. Standalone attribute: `attribute-name`
3. Attribute with value: `attribute-name="true"` and `attribute-name="false"`
4. CamelCase attribute: `attributeName="true"` and `attributeName="false"`
5. Property binding with camelCase: `[attributeName]="value"`

Use the helper method in assertions:

```typescript
expect(directive.isAttributeNameEnabled()).toBe(true);
```
