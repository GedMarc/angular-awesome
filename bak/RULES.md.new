# Angular Awesome Implementation Rules

## Data Binding and Angular Integration

The most important rule for this project is to ensure proper data binding between Angular and the web awesome framework. The web awesome framework handles the core functionality, but the Angular wrapper must handle the Angular integration, including two-way data binding and form validation.

### What to Avoid:

1. **No Formatting Logic**: Do not add logic that formats or transforms the displayed values. The web awesome framework handles all display formatting.

2. **No Business Logic**: Do not add business logic or validation rules that should be handled by the web awesome framework.

### What to Do:

1. **Define Inputs and Outputs**: Define inputs and outputs that match the web awesome component's API.

2. **Implement Two-Way Binding**: Ensure all directives support two-way data binding using Angular's model() API.

3. **Support ngModel**: Make directives compatible with ngModel for use in Angular forms.

4. **Handle Events**: Add necessary event handlers to ensure data flows correctly between Angular and web awesome components.

5. **Support Validation**: Ensure directives properly support Angular form validation.

6. **Use .apply() for model inputs**: When updating model inputs, use the `.apply()` method instead of `.set()`.
   ```typescript
   // Incorrect
   this.value.set(newValue);

   // Correct
   this.value.apply(newValue);
   ```

## Handling Standalone Attributes

When implementing directives that need to support standalone attributes (attributes without values), follow these guidelines:

### 1. Use Two or Three Inputs for Each Attribute

For non-hyphenated attributes (e.g., "clearable"):

```typescript
// Regular input for property binding
attributeName = input<boolean>(false);

// Separate input for the standalone attribute
attributeNameAttr = input<string | boolean>('', { alias: 'attributeName' });
```

For hyphenated attributes (e.g., "password-toggle"):

```typescript
// Regular input for property binding
attributeName = input<boolean>(false);

// Separate input for the kebab-case standalone attribute
attributeNameAttr = input<string | boolean>('', { alias: 'attribute-name' });

// Separate input for the camelCase standalone attribute
attributeNameAttrCamel = input<string | boolean>('', { alias: 'attributeName' });
```

### 2. Create a Helper Method

Create a helper method to determine if the attribute is enabled, checking all possible inputs:

For non-hyphenated attributes:

```typescript
isAttributeNameEnabled(): boolean {
  return this.attributeName() ||
         this.attributeNameAttr() === '' ||
         this.attributeNameAttr() === 'true';
}
```

For hyphenated attributes:

```typescript
isAttributeNameEnabled(): boolean {
  return this.attributeName() ||
         this.attributeNameAttr() === '' ||
         this.attributeNameAttr() === 'true' ||
         this.attributeNameAttrCamel() === '' ||
         this.attributeNameAttrCamel() === 'true';
}
```

### 3. Use the Helper Method in Templates and Tests

When checking if the attribute is enabled, use the helper method instead of directly accessing the inputs:

```typescript
// In tests
expect(directive.isAttributeNameEnabled()).toBe(true);

// In templates
<div *ngIf="isAttributeNameEnabled()">...</div>
```

## Examples

### Password Toggle (Hyphenated Attribute)

```typescript
// Regular input for property binding
passwordToggle = input<boolean>(false);

// Separate input for the kebab-case standalone attribute
passwordToggleAttr = input<string | boolean>('', { alias: 'password-toggle' });

// Separate input for the camelCase standalone attribute
passwordToggleAttrCamel = input<string | boolean>('', { alias: 'passwordToggle' });

// Helper method to determine if password toggle is enabled
isPasswordToggleEnabled(): boolean {
  return this.passwordToggle() ||
         this.passwordToggleAttr() === '' ||
         this.passwordToggleAttr() === 'true' ||
         this.passwordToggleAttrCamel() === '' ||
         this.passwordToggleAttrCamel() === 'true';
}
```

### Clearable (Non-Hyphenated Attribute)

```typescript
// Regular input for property binding
clearable = input<boolean>(false);

// Separate input for the standalone attribute
clearableAttr = input<string | boolean>('', { alias: 'clearable' });

// Helper method to determine if clearable is enabled
isClearableEnabled(): boolean {
  return this.clearable() ||
         this.clearableAttr() === '' ||
         this.clearableAttr() === 'true';
}
```

## Testing

When testing directives with standalone attributes, create tests for all possible syntax variations:

For non-hyphenated attributes:
1. Property binding: `[attribute]="value"`
2. Standalone attribute: `attribute`
3. Attribute with value: `attribute="true"` and `attribute="false"`

For hyphenated attributes:
1. Property binding: `[attribute]="value"`
2. Standalone attribute: `attribute-name`
3. Attribute with value: `attribute-name="true"` and `attribute-name="false"`
4. CamelCase attribute: `attributeName="true"` and `attributeName="false"`
5. Property binding with camelCase: `[attributeName]="value"`

Use the helper method in assertions:

```typescript
expect(directive.isAttributeNameEnabled()).toBe(true);
```
